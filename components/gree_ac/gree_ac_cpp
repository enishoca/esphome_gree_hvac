#include "gree_ac.h"
#include "esphome/core/log.h"
#include "esphome/core/helpers.h"

namespace esphome {
namespace gree_ac {

// Byte positions in packets
static const uint8_t FORCE_UPDATE_BYTE = 7;
static const uint8_t MODE_BYTE = 8;
static const uint8_t MODE_MASK = 0xF0;
static const uint8_t FAN_MASK = 0x0F;
static const uint8_t TEMPERATURE_BYTE = 9;
static const uint8_t PRESET_BYTE = 10;
static const uint8_t SWING_BYTE = 12;
static const uint8_t DISPLAY_BYTE = 13;
static const uint8_t PLASMA_BYTE = 6;
static const uint8_t PLASMA_MASK = 0x04;
static const uint8_t SLEEP_BYTE = 4;
static const uint8_t SLEEP_MASK = 0x08;
static const uint8_t XFAN_BYTE = 6;
static const uint8_t XFAN_MASK = 0x08;
static const uint8_t INDOOR_TEMP_BYTE = 46;
static const uint8_t CRC_BYTE = 46;

void GreeAC::setup() {
  ESP_LOGI(TAG, "Gree AC component v%s starting...", VERSION);
  this->last_handshake_attempt_ = millis();
  this->last_packet_sent_ = millis();
  
  // Setup callbacks for optional components
  this->setup_select_callbacks_();
  this->setup_switch_callbacks_();
  
  // Setup external temperature sensor callback if configured
  if (this->current_temperature_sensor_ != nullptr) {
    this->current_temperature_sensor_->add_on_state_callback([this](float state) {
      this->current_temperature = state;
      this->publish_state();
    });
  }
}

void GreeAC::loop() {
  this->read_uart_data_();
  
  // Check if we need to retry handshake
  uint32_t now = millis();
  if (this->state_ == ACState::INITIALIZING) {
    if (now - this->last_handshake_attempt_ >= HANDSHAKE_RETRY_INTERVAL_MS) {
      ESP_LOGD(TAG, "Retrying handshake...");
      this->last_handshake_attempt_ = now;
      this->send_packet_();
    }
  }
  
  // Check for timeout (AC stopped responding)
  if (this->state_ == ACState::READY) {
    if (now - this->last_packet_received_ >= PACKET_TIMEOUT_MS) {
      ESP_LOGW(TAG, "AC communication timeout, waiting for response...");
      this->state_ = ACState::INITIALIZING;
      this->mark_failed();
    }
  }
}

void GreeAC::update() {
  // Periodic update - send current state
  if (this->state_ == ACState::READY) {
    this->send_packet_();
  }
}

void GreeAC::dump_config() {
  ESP_LOGCONFIG(TAG, "Gree AC:");
  ESP_LOGCONFIG(TAG, "  Update interval: %u ms", this->get_update_interval());
  this->check_uart_settings(4800, 1, uart::UART_CONFIG_PARITY_EVEN, 8);
  
  if (this->horizontal_swing_select_ != nullptr) {
    ESP_LOGCONFIG(TAG, "  Horizontal swing: configured");
  }
  if (this->vertical_swing_select_ != nullptr) {
    ESP_LOGCONFIG(TAG, "  Vertical swing: configured");
  }
  if (this->display_select_ != nullptr) {
    ESP_LOGCONFIG(TAG, "  Display: configured");
  }
  if (this->plasma_switch_ != nullptr) {
    ESP_LOGCONFIG(TAG, "  Plasma: configured");
  }
  if (this->sleep_switch_ != nullptr) {
    ESP_LOGCONFIG(TAG, "  Sleep: configured");
  }
  if (this->xfan_switch_ != nullptr) {
    ESP_LOGCONFIG(TAG, "  X-Fan: configured");
  }
}

climate::ClimateTraits GreeAC::traits() {
  auto traits = climate::ClimateTraits();
  
  traits.set_supports_current_temperature(true);
  traits.set_visual_min_temperature(MIN_TEMPERATURE);
  traits.set_visual_max_temperature(MAX_TEMPERATURE);
  traits.set_visual_temperature_step(TEMPERATURE_STEP);
  
  traits.set_supported_modes({
      climate::CLIMATE_MODE_OFF,
      climate::CLIMATE_MODE_AUTO,
      climate::CLIMATE_MODE_COOL,
      climate::CLIMATE_MODE_DRY,
      climate::CLIMATE_MODE_FAN_ONLY,
      climate::CLIMATE_MODE_HEAT});
  
  traits.set_supported_custom_fan_modes({
      fan_modes::FAN_AUTO,
      fan_modes::FAN_LOW,
      fan_modes::FAN_MEDIUM,
      fan_modes::FAN_HIGH});
  
  // Add swing support
  traits.set_supported_swing_modes({
      climate::CLIMATE_SWING_OFF,
      climate::CLIMATE_SWING_VERTICAL,
      climate::CLIMATE_SWING_HORIZONTAL,
      climate::CLIMATE_SWING_BOTH});
  
  // Add presets
  for (auto preset : this->supported_presets_) {
    traits.add_supported_preset(preset);
  }
  traits.add_supported_preset(climate::CLIMATE_PRESET_NONE);
  
  return traits;
}

void GreeAC::control(const climate::ClimateCall &call) {
  if (this->state_ != ACState::READY) {
    ESP_LOGW(TAG, "AC not ready, ignoring control request");
    return;
  }
  
  ESP_LOGD(TAG, "Control called");
  
  // Mark that we have an update to send
  this->update_state_ = UpdateState::UPDATE_PENDING;
  
  // Handle mode change
  if (call.get_mode().has_value()) {
    this->mode = *call.get_mode();
  }
  
  // Handle target temperature
  if (call.get_target_temperature().has_value()) {
    float temp = *call.get_target_temperature();
    if (temp >= MIN_TEMPERATURE && temp <= MAX_TEMPERATURE) {
      this->target_temperature = temp;
    }
  }
  
  // Handle fan mode
  if (call.get_custom_fan_mode().has_value()) {
    this->custom_fan_mode = *call.get_custom_fan_mode();
  }
  
  // Handle swing mode
  if (call.get_swing_mode().has_value()) {
    this->swing_mode = *call.get_swing_mode();
    this->update_swing_states_();
  }
  
  // Handle preset
  if (call.get_preset().has_value()) {
    this->preset = *call.get_preset();
  }
  
  // Send the update immediately
  this->send_packet_();
}

void GreeAC::read_uart_data_() {
  while (this->available()) {
    uint8_t byte;
    this->read_byte(&byte);
    
    switch (this->serial_state_) {
      case SerialState::WAIT_SYNC:
        if (byte == GREE_START_BYTE) {
          this->rx_buffer_[0] = byte;
          this->rx_index_ = 1;
          this->serial_state_ = SerialState::RECEIVE;
        }
        break;
        
      case SerialState::RECEIVE:
        this->rx_buffer_[this->rx_index_++] = byte;
        
        // Check for second sync byte
        if (this->rx_index_ == 2 && byte != GREE_START_BYTE) {
          this->serial_state_ = SerialState::WAIT_SYNC;
          this->rx_index_ = 0;
          break;
        }
        
        // Read length byte
        if (this->rx_index_ == 3) {
          uint8_t packet_length = byte;
          if (packet_length + 3 > GREE_RX_BUFFER_SIZE) {
            ESP_LOGW(TAG, "Packet too large: %d", packet_length);
            this->serial_state_ = SerialState::WAIT_SYNC;
            this->rx_index_ = 0;
          }
        }
        
        // Check if packet is complete
        if (this->rx_index_ >= 3) {
          uint8_t expected_length = this->rx_buffer_[2] + 3;  // length + header
          if (this->rx_index_ >= expected_length) {
            this->serial_state_ = SerialState::COMPLETE;
          }
        }
        
        // Prevent buffer overflow
        if (this->rx_index_ >= GREE_RX_BUFFER_SIZE) {
          ESP_LOGW(TAG, "Buffer overflow");
          this->serial_state_ = SerialState::WAIT_SYNC;
          this->rx_index_ = 0;
        }
        break;
        
      case SerialState::COMPLETE:
        // Should not receive data in this state
        break;
    }
    
    // Process complete packet
    if (this->serial_state_ == SerialState::COMPLETE) {
      this->log_packet_(this->rx_buffer_, this->rx_index_, false);
      
      if (this->verify_packet_(this->rx_buffer_, this->rx_index_)) {
        this->handle_packet_(this->rx_buffer_, this->rx_index_);
        this->last_packet_received_ = millis();
        
        // Mark as ready if we were initializing
        if (this->state_ != ACState::READY) {
          ESP_LOGI(TAG, "AC communication established");
          this->state_ = ACState::READY;
          this->mark_ready();
        }
      }
      
      // Reset for next packet
      this->serial_state_ = SerialState::WAIT_SYNC;
      this->rx_index_ = 0;
      memset(this->rx_buffer_, 0, GREE_RX_BUFFER_SIZE);
    }
  }
}

void GreeAC::send_packet_() {
  uint32_t now = millis();
  
  // Rate limiting
  if (now - this->last_packet_sent_ < MIN_PACKET_INTERVAL_MS) {
    return;
  }
  
  this->build_state_packet_();
  
  // Calculate and set checksum
  this->tx_buffer_[CRC_BYTE] = this->calculate_checksum_(this->tx_buffer_, sizeof(this->tx_buffer_));
  
  this->write_array(this->tx_buffer_, sizeof(this->tx_buffer_));
  this->log_packet_(this->tx_buffer_, sizeof(this->tx_buffer_), true);
  
  this->last_packet_sent_ = now;
  
  // Clear update flag after sending
  if (this->update_state_ == UpdateState::UPDATE_PENDING) {
    this->update_state_ = UpdateState::NO_UPDATE;
  }
}

void GreeAC::build_state_packet_() {
  // Set force update flag if we have changes
  if (this->update_state_ == UpdateState::UPDATE_PENDING) {
    this->tx_buffer_[FORCE_UPDATE_BYTE] = 0xAF;
  } else {
    this->tx_buffer_[FORCE_UPDATE_BYTE] = 0x00;
  }
  
  // Set mode and fan speed
  uint8_t mode_byte = 0;
  uint8_t fan_byte = 0;
  
  switch (this->mode) {
    case climate::CLIMATE_MODE_OFF:
      mode_byte = static_cast<uint8_t>(ACMode::OFF);
      break;
    case climate::CLIMATE_MODE_AUTO:
      mode_byte = static_cast<uint8_t>(ACMode::AUTO);
      break;
    case climate::CLIMATE_MODE_COOL:
      mode_byte = static_cast<uint8_t>(ACMode::COOL);
      break;
    case climate::CLIMATE_MODE_DRY:
      mode_byte = static_cast<uint8_t>(ACMode::DRY);
      fan_byte = static_cast<uint8_t>(ACFanSpeed::LOW);  // DRY mode only supports LOW
      break;
    case climate::CLIMATE_MODE_FAN_ONLY:
      mode_byte = static_cast<uint8_t>(ACMode::FAN_ONLY);
      break;
    case climate::CLIMATE_MODE_HEAT:
      mode_byte = static_cast<uint8_t>(ACMode::HEAT);
      break;
    default:
      mode_byte = static_cast<uint8_t>(ACMode::OFF);
      break;
  }
  
  // Set fan speed (unless in DRY mode)
  if (this->mode != climate::CLIMATE_MODE_DRY && this->custom_fan_mode.has_value()) {
    const char *fan_mode = this->custom_fan_mode.value().c_str();
    if (strcmp(fan_mode, fan_modes::FAN_AUTO) == 0) {
      fan_byte = static_cast<uint8_t>(ACFanSpeed::AUTO);
    } else if (strcmp(fan_mode, fan_modes::FAN_LOW) == 0) {
      fan_byte = static_cast<uint8_t>(ACFanSpeed::LOW);
    } else if (strcmp(fan_mode, fan_modes::FAN_MEDIUM) == 0) {
      fan_byte = static_cast<uint8_t>(ACFanSpeed::MEDIUM);
    } else if (strcmp(fan_mode, fan_modes::FAN_HIGH) == 0) {
      fan_byte = static_cast<uint8_t>(ACFanSpeed::HIGH);
    }
  }
  
  this->tx_buffer_[MODE_BYTE] = mode_byte | fan_byte;
  
  // Set temperature
  if (this->mode != climate::CLIMATE_MODE_OFF) {
    uint8_t temp = static_cast<uint8_t>((this->target_temperature - MIN_TEMPERATURE) * 16);
    this->tx_buffer_[TEMPERATURE_BYTE] = temp;
  }
  
  // Set preset (turbo/boost)
  if (this->preset == climate::CLIMATE_PRESET_BOOST) {
    if (this->mode == climate::CLIMATE_MODE_COOL) {
      this->tx_buffer_[PRESET_BYTE] = 7;
    } else if (this->mode == climate::CLIMATE_MODE_HEAT) {
      this->tx_buffer_[PRESET_BYTE] = 15;
    }
  } else {
    if (this->mode == climate::CLIMATE_MODE_COOL) {
      this->tx_buffer_[PRESET_BYTE] = 6;
    } else if (this->mode == climate::CLIMATE_MODE_HEAT) {
      this->tx_buffer_[PRESET_BYTE] = 14;
    } else {
      this->tx_buffer_[PRESET_BYTE] = 2;
    }
  }
  
  // Set display (show current temperature)
  this->tx_buffer_[DISPLAY_BYTE] = (this->display_state_ == "On") ? 0x20 : 0x00;
  
  // Set switches
  if (this->plasma_state_) {
    this->tx_buffer_[PLASMA_BYTE] |= PLASMA_MASK;
  } else {
    this->tx_buffer_[PLASMA_BYTE] &= ~PLASMA_MASK;
  }
  
  if (this->sleep_state_) {
    this->tx_buffer_[SLEEP_BYTE] |= SLEEP_MASK;
  } else {
    this->tx_buffer_[SLEEP_BYTE] &= ~SLEEP_MASK;
  }
  
  if (this->xfan_state_) {
    this->tx_buffer_[XFAN_BYTE] |= XFAN_MASK;
  } else {
    this->tx_buffer_[XFAN_BYTE] &= ~XFAN_MASK;
  }
}

bool GreeAC::verify_packet_(const uint8_t *data, uint8_t size) {
  if (size < 5) {
    ESP_LOGW(TAG, "Packet too small: %d", size);
    return false;
  }
  
  // Check sync bytes
  if (data[0] != GREE_START_BYTE || data[1] != GREE_START_BYTE) {
    ESP_LOGW(TAG, "Invalid sync bytes");
    return false;
  }
  
  // Check packet type (only process unit reports)
  if (data[3] != CMD_IN_UNIT_REPORT) {
    ESP_LOGV(TAG, "Ignoring packet type: 0x%02X", data[3]);
    return false;
  }
  
  // Verify checksum
  uint8_t calculated_crc = this->calculate_checksum_(data, size);
  uint8_t received_crc = data[size - 1];
  
  if (calculated_crc != received_crc) {
    ESP_LOGW(TAG, "Checksum mismatch: calculated=0x%02X, received=0x%02X", calculated_crc, received_crc);
    return false;
  }
  
  return true;
}

void GreeAC::handle_packet_(const uint8_t *data, uint8_t size) {
  // Parse state from packet (skip header: 2 sync + length + type)
  const uint8_t *payload = data + 4;
  this->parse_state_packet_(payload);
  this->publish_state();
}

void GreeAC::parse_state_packet_(const uint8_t *data) {
  // Parse mode
  uint8_t mode_byte = data[MODE_BYTE - 4];  // Adjust for payload offset
  this->mode = this->parse_mode_(mode_byte);
  
  // Parse fan mode
  const char *fan_mode = this->parse_fan_mode_(mode_byte);
  this->custom_fan_mode = fan_mode;
  
  // Parse target temperature
  float target_temp = (data[TEMPERATURE_BYTE - 4] / 16) + MIN_TEMPERATURE;
  this->target_temperature = target_temp;
  
  // Parse current temperature (if no external sensor)
  if (this->current_temperature_sensor_ == nullptr) {
    float current_temp = data[INDOOR_TEMP_BYTE - 4] - 40;
    if (current_temp < TEMPERATURE_THRESHOLD) {
      this->current_temperature = current_temp;
    }
  }
  
  // Parse preset
  uint8_t preset_byte = data[PRESET_BYTE - 4];
  ACMode current_mode = static_cast<ACMode>(mode_byte & MODE_MASK);
  this->preset = this->parse_preset_(preset_byte, current_mode);
  
  // Parse switches
  this->plasma_state_ = (data[PLASMA_BYTE - 4] & PLASMA_MASK) != 0;
  this->sleep_state_ = (data[SLEEP_BYTE - 4] & SLEEP_MASK) != 0;
  this->xfan_state_ = (data[XFAN_BYTE - 4] & XFAN_MASK) != 0;
  
  // Update switch states
  if (this->plasma_switch_ != nullptr) {
    this->plasma_switch_->publish_state(this->plasma_state_);
  }
  if (this->sleep_switch_ != nullptr) {
    this->sleep_switch_->publish_state(this->sleep_state_);
  }
  if (this->xfan_switch_ != nullptr) {
    this->xfan_switch_->publish_state(this->xfan_state_);
  }
  
  // Determine action
  this->action = this->determine_action_();
}

climate::ClimateMode GreeAC::parse_mode_(uint8_t mode_byte) {
  uint8_t mode = mode_byte & MODE_MASK;
  
  switch (mode) {
    case static_cast<uint8_t>(ACMode::OFF):
      return climate::CLIMATE_MODE_OFF;
    case static_cast<uint8_t>(ACMode::AUTO):
      return climate::CLIMATE_MODE_AUTO;
    case static_cast<uint8_t>(ACMode::COOL):
      return climate::CLIMATE_MODE_COOL;
    case static_cast<uint8_t>(ACMode::DRY):
      return climate::CLIMATE_MODE_DRY;
    case static_cast<uint8_t>(ACMode::FAN_ONLY):
      return climate::CLIMATE_MODE_FAN_ONLY;
    case static_cast<uint8_t>(ACMode::HEAT):
      return climate::CLIMATE_MODE_HEAT;
    default:
      ESP_LOGW(TAG, "Unknown mode: 0x%02X", mode);
      return climate::CLIMATE_MODE_OFF;
  }
}

const char *GreeAC::parse_fan_mode_(uint8_t mode_byte) {
  uint8_t fan = mode_byte & FAN_MASK;
  
  switch (fan) {
    case static_cast<uint8_t>(ACFanSpeed::AUTO):
      return fan_modes::FAN_AUTO;
    case static_cast<uint8_t>(ACFanSpeed::LOW):
      return fan_modes::FAN_LOW;
    case static_cast<uint8_t>(ACFanSpeed::MEDIUM):
      return fan_modes::FAN_MEDIUM;
    case static_cast<uint8_t>(ACFanSpeed::HIGH):
      return fan_modes::FAN_HIGH;
    default:
      return fan_modes::FAN_AUTO;
  }
}

climate::ClimatePreset GreeAC::parse_preset_(uint8_t preset_byte, ACMode mode) {
  if ((mode == ACMode::COOL && preset_byte == 7) || (mode == ACMode::HEAT && preset_byte == 15)) {
    return climate::CLIMATE_PRESET_BOOST;
  }
  return climate::CLIMATE_PRESET_NONE;
}

climate::ClimateAction GreeAC::determine_action_() {
  if (this->mode == climate::CLIMATE_MODE_OFF) {
    return climate::CLIMATE_ACTION_OFF;
  } else if (this->mode == climate::CLIMATE_MODE_FAN_ONLY) {
    return climate::CLIMATE_ACTION_FAN;
  } else if (this->mode == climate::CLIMATE_MODE_DRY) {
    return climate::CLIMATE_ACTION_DRYING;
  } else if ((this->mode == climate::CLIMATE_MODE_COOL || this->mode == climate::CLIMATE_MODE_AUTO) &&
             this->current_temperature + TEMPERATURE_TOLERANCE >= this->target_temperature) {
    return climate::CLIMATE_ACTION_COOLING;
  } else if ((this->mode == climate::CLIMATE_MODE_HEAT || this->mode == climate::CLIMATE_MODE_AUTO) &&
             this->current_temperature - TEMPERATURE_TOLERANCE <= this->target_temperature) {
    return climate::CLIMATE_ACTION_HEATING;
  } else {
    return climate::CLIMATE_ACTION_IDLE;
  }
}

uint8_t GreeAC::calculate_checksum_(const uint8_t *data, size_t size) {
  uint8_t sum = 0;
  // Skip first 2 sync bytes and last checksum byte
  for (size_t i = 2; i < size - 1; i++) {
    sum += data[i];
  }
  return sum;
}

void GreeAC::log_packet_(const uint8_t *data, uint8_t size, bool outgoing) {
  if (outgoing) {
    ESP_LOGV(TAG, "TX: %s", format_hex_pretty(data, size).c_str());
  } else {
    ESP_LOGV(TAG, "RX: %s", format_hex_pretty(data, size).c_str());
  }
}

void GreeAC::update_swing_states_() {
  switch (this->swing_mode) {
    case climate::CLIMATE_SWING_OFF:
      this->horizontal_swing_state_ = "Center";
      this->vertical_swing_state_ = "Center";
      break;
    case climate::CLIMATE_SWING_VERTICAL:
      this->horizontal_swing_state_ = "Center";
      this->vertical_swing_state_ = "Full Swing";
      break;
    case climate::CLIMATE_SWING_HORIZONTAL:
      this->horizontal_swing_state_ = "Full Swing";
      this->vertical_swing_state_ = "Center";
      break;
    case climate::CLIMATE_SWING_BOTH:
      this->horizontal_swing_state_ = "Full Swing";
      this->vertical_swing_state_ = "Full Swing";
      break;
  }
  
  if (this->horizontal_swing_select_ != nullptr) {
    this->horizontal_swing_select_->publish_state(this->horizontal_swing_state_);
  }
  if (this->vertical_swing_select_ != nullptr) {
    this->vertical_swing_select_->publish_state(this->vertical_swing_state_);
  }
}

void GreeAC::setup_select_callbacks_() {
  if (this->horizontal_swing_select_ != nullptr) {
    this->horizontal_swing_select_->add_on_state_callback(
        [this](const std::string &value, size_t index) { this->on_horizontal_swing_change_(value); });
  }
  
  if (this->vertical_swing_select_ != nullptr) {
    this->vertical_swing_select_->add_on_state_callback(
        [this](const std::string &value, size_t index) { this->on_vertical_swing_change_(value); });
  }
  
  if (this->display_select_ != nullptr) {
    this->display_select_->add_on_state_callback(
        [this](const std::string &value, size_t index) { this->on_display_change_(value); });
  }
}

void GreeAC::setup_switch_callbacks_() {
  if (this->plasma_switch_ != nullptr) {
    this->plasma_switch_->add_on_state_callback([this](bool state) { this->on_plasma_change_(state); });
  }
  
  if (this->sleep_switch_ != nullptr) {
    this->sleep_switch_->add_on_state_callback([this](bool state) { this->on_sleep_change_(state); });
  }
  
  if (this->xfan_switch_ != nullptr) {
    this->xfan_switch_->add_on_state_callback([this](bool state) { this->on_xfan_change_(state); });
  }
}

void GreeAC::on_horizontal_swing_change_(const std::string &value) {
  if (this->state_ != ACState::READY || value == this->horizontal_swing_state_) {
    return;
  }
  
  ESP_LOGD(TAG, "Horizontal swing changed to: %s", value.c_str());
  this->horizontal_swing_state_ = value;
  this->update_state_ = UpdateState::UPDATE_PENDING;
  this->send_packet_();
}

void GreeAC::on_vertical_swing_change_(const std::string &value) {
  if (this->state_ != ACState::READY || value == this->vertical_swing_state_) {
    return;
  }
  
  ESP_LOGD(TAG, "Vertical swing changed to: %s", value.c_str());
  this->vertical_swing_state_ = value;
  this->update_state_ = UpdateState::UPDATE_PENDING;
  this->send_packet_();
}

void GreeAC::on_display_change_(const std::string &value) {
  if (this->state_ != ACState::READY || value == this->display_state_) {
    return;
  }
  
  ESP_LOGD(TAG, "Display changed to: %s", value.c_str());
  this->display_state_ = value;
  this->update_state_ = UpdateState::UPDATE_PENDING;
  this->send_packet_();
}

void GreeAC::on_plasma_change_(bool state) {
  if (this->state_ != ACState::READY || state == this->plasma_state_) {
    return;
  }
  
  ESP_LOGD(TAG, "Plasma changed to: %d", state);
  this->plasma_state_ = state;
  this->update_state_ = UpdateState::UPDATE_PENDING;
  this->send_packet_();
}

void GreeAC::on_sleep_change_(bool state) {
  if (this->state_ != ACState::READY || state == this->sleep_state_) {
    return;
  }
  
  ESP_LOGD(TAG, "Sleep changed to: %d", state);
  this->sleep_state_ = state;
  this->update_state_ = UpdateState::UPDATE_PENDING;
  this->send_packet_();
}

void GreeAC::on_xfan_change_(bool state) {
  if (this->state_ != ACState::READY || state == this->xfan_state_) {
    return;
  }
  
  ESP_LOGD(TAG, "X-Fan changed to: %d", state);
  this->xfan_state_ = state;
  this->update_state_ = UpdateState::UPDATE_PENDING;
  this->send_packet_();
}

}  // namespace gree_ac
}  // namespace esphome
